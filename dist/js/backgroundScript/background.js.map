{"version":3,"file":"background.js","sources":["../../../src/backgroundScript/background.mjs"],"sourcesContent":["import { messageAllTabs, sortObjectArrayByKey } from \"../util\"\r\nimport { DEFAULT_OPTIONS, EXTENSION_ALIAS, IS_DEBUG } from \"../const\"\r\nimport { ankiRequest } from \"../ankiConnectUtil\"\r\n// structure:\r\n/* {\r\n  LANGUAGE: {\r\n    genders: {\r\n      m: MASCULINE,\r\n      f: FEMININE,\r\n      n: NEUTRAL\r\n    },\r\n    flagURL: FLAGURL, \r\n    dict: {\r\n      WORD: GENDER, \r\n      . . .\r\n    },\r\n  }\r\n}\r\n*/\r\n\r\n(async () => {\r\nvar languageData = {}\r\n\r\nchrome.runtime.onInstalled.addListener(() => {\r\n  chrome.storage.sync.set({options: DEFAULT_OPTIONS})\r\n})\r\n\r\nlet options = DEFAULT_OPTIONS\r\n\r\nfunction initLanguages() {\r\n  let selectedLanguages = options.selectedLanguages.value\r\n  // set initial word dictionary\r\n  selectedLanguages.map((language) => {\r\n    languageData[language] = {}\r\n  })\r\n  updateLanguageDict(languageData, selectedLanguages)\r\n  updateLanguageGenders(languageData, selectedLanguages)\r\n  updateLanguageFlagURLs(languageData, selectedLanguages)\r\n  // console.log(languageData)\r\n\r\n}\r\n// setup: retrieve options and update local maps\r\nchrome.storage.sync.get('options').then(result => {\r\n  options = result.data || DEFAULT_OPTIONS\r\n  initLanguages()\r\n})\r\n\r\nvar isExtensionOn = options.shouldStartEnabled.value\r\nupdateBadgeText()\r\n\r\n// load word dictionary into memory\r\nfunction updateLanguageDict(languageData, selectedLanguages) {\r\n  selectedLanguages.map(async (language) => {\r\n    // initialize map\r\n    languageData[language].dict = {}\r\n\r\n    // for each language, read its corresponding csv file for `WORD, GENDER` entries\r\n    const filePath = chrome.runtime.getURL('data/dicts/' + language + \".csv\")\r\n    const response = await fetch(filePath)\r\n    if (response.ok) {\r\n      let text = await response.text()\r\n      text.split('\\n').map(line => {\r\n        const [word, gender] = line.split(',')\r\n        if (word && gender) {\r\n          languageData[language].dict[word] = gender.trim()\r\n        }\r\n      }) \r\n      console.log(language, 'language dict is loaded with', Object.keys(languageData[language].dict).length, 'entries')\r\n    } else {\r\n      console.error(EXTENSION_ALIAS + ' was unable to load dict for ' + language)\r\n    }\r\n  })\r\n}\r\n\r\n// load genders, eg. {de: {f: 'feminin', . . .}, . . .}\r\nasync function updateLanguageGenders(languageData, selectedLanguages) {\r\n  const filePath = chrome.runtime.getURL('data/genders.csv')\r\n  const response = await fetch(filePath)\r\n  if (response.ok) {\r\n    let text = await response.text()\r\n    // returns an object with corresponding {word: gender}\r\n    let langToGenderObj = genderCSVToObj(text)\r\n    Object.entries(langToGenderObj).forEach(([lang, genders]) => {\r\n      try {\r\n        languageData[lang].genders = genders        \r\n      } catch (e) {\r\n        if (!(e instanceof TypeError)) throw(e)\r\n      }\r\n    })\r\n  }\r\n}\r\n\r\nfunction updateLanguageFlagURLs(languageData, selectedLanguages) {\r\n  selectedLanguages.map( (language) => {\r\n    languageData[language].flagURL = chrome.runtime.getURL(`data/flags/${language}.svg`)\r\n  })\r\n}\r\n\r\n// listen to tab events\r\nchrome.runtime.onMessage.addListener(\r\n  (request, sender, sendResponse) => {\r\n    switch (request.type) { \r\n\r\n      case 'getGender':\r\n        let data = []\r\n        options.selectedLanguages.value.map(language => {\r\n          const gender = languageData[language].dict[request.word]\r\n          const wordForGender = languageData[language].genders[gender]\r\n          const flagURL = languageData[language].flagURL\r\n          if (gender) data.push({countryCode: language, gender, wordForGender, flagURL, isSvelteComponent: false,})\r\n        })\r\n        sortObjectArrayByKey(data, 'language')\r\n        sendResponse({data})\r\n        break\r\n\r\n      case 'isExtensionOn':\r\n        sendResponse({isExtensionOn})\r\n        break\r\n        \r\n      case 'updateOptions':\r\n        options = request.data\r\n        initLanguages()\r\n        messageAllTabs({type: 'updateOptions', data: request.data})\r\n        break\r\n\r\n      case 'runAnkiRequest':\r\n        ankiRequest(request.data.action, request.data.params).then(response => {\r\n          sendResponse({response})\r\n        })\r\n        return true\r\n        break\r\n\r\n      default:\r\n        break\r\n    }\r\n  }\r\n)\r\n\r\n// TODO: pay attention to when this (note from the future: never leave a comment unfinished, now idk what this was about)\r\nchrome.tabs.onUpdated.addListener((tabId, changeInfo, tab) => {\r\n  if (changeInfo.status == 'complete') {\r\n  }\r\n})\r\n\r\n\r\nchrome.action.setBadgeBackgroundColor({\r\n  color: [245, 30, 30, 255]\r\n});\r\n// listen to click on extension icon\r\nchrome.action.onClicked.addListener((tab) => {\r\n  messageAllTabs({type: isExtensionOn ? 'disableExtension' : 'enableExtension'})\r\n\r\n  isExtensionOn = !isExtensionOn\r\n  updateBadgeText()\r\n  console.log('toggling extension! now', isExtensionOn)\r\n});\r\n\r\nfunction updateBadgeText() {\r\n  if (isExtensionOn) {\r\n    chrome.action.setBadgeText({text: 'On'})\r\n  } else {\r\n    chrome.action.setBadgeText({text: ''})\r\n  }  \r\n}\r\n\r\n// yes i wrote my own parser, totally very fail-safe\r\nfunction genderCSVToObj(stringCSV) {\r\n  let output = {}\r\n  const lines = stringCSV.split('\\n')\r\n  // we already know how the header is so let's just skip it by setting i to 1\r\n  for (let i=1; i<lines.length; i++) {\r\n      const contents = lines[i].split(',')\r\n      output[contents[0]] = {\r\n        'm': contents[1],\r\n        'f': contents[2],\r\n        'n': contents[3].trim()\r\n      }\r\n  }\r\n  return output\r\n}\r\n  })()"],"names":["languageData","DEFAULT_OPTIONS","options","initLanguages","selectedLanguages","language","updateLanguageDict","updateLanguageGenders","updateLanguageFlagURLs","result","isExtensionOn","updateBadgeText","filePath","response","line","word","gender","EXTENSION_ALIAS","text","langToGenderObj","genderCSVToObj","lang","genders","e","request","sender","sendResponse","data","wordForGender","flagURL","sortObjectArrayByKey","messageAllTabs","ankiRequest","tabId","changeInfo","tab","stringCSV","output","lines","i","contents"],"mappings":"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"}