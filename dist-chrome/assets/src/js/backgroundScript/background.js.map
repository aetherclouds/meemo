{"version":3,"file":"background.js","sources":["../../../../../src/js/backgroundScript/background.mjs"],"sourcesContent":["import { messageAllTabs, sortObjectArrayByKey } from \"../util\"\r\nimport { DEFAULT_OPTIONS, EXTENSION_ALIAS, IN_DEV, IS_CHROME, browserAction, browserStorageSync } from \"../const\"\r\nimport { ankiRequest } from \"../ankiConnectUtil\"\r\n// LanguageData structure:\r\n/* \r\n{\r\n  LANGUAGE: {\r\n    genders: {\r\n      m: MASCULINE,\r\n      f: FEMININE,\r\n      n: NEUTRAL\r\n    },\r\n    flagURL: FLAGURL, \r\n    dict: {\r\n      WORD: GENDER, \r\n      . . .\r\n    },\r\n  }\r\n}\r\n*/\r\n\r\n(async () => {\r\nvar languageData = {}\r\n\r\nconsole.log('isOnChrome?', IS_CHROME)\r\nchrome.runtime.onInstalled.addListener(() => {\r\n  chrome.storage.sync.set({options: DEFAULT_OPTIONS})\r\n  // redirect to options on install\r\n  // TODO: make options page look better on firefox so that I can do this without it being embarrassing\r\n  if (IS_CHROME && !IN_DEV) {\r\n    chrome.tabs.create({\r\n      url: 'chrome://extensions/?options='+chrome.runtime.id,\r\n      active: true,\r\n    })\r\n  }\r\n})\r\n\r\nlet options = DEFAULT_OPTIONS\r\n// try load from sync\r\nbrowserStorageSync.get('options').then(result => {\r\n    options = result.options || DEFAULT_OPTIONS\r\n})\r\n\r\nvar isExtensionOn = options.shouldStartEnabled.value\r\nupdateBadgeText()\r\ninitLanguages()\r\n\r\nfunction initLanguages() {\r\n  let selectedLanguages = options.selectedLanguages.value\r\n  // set initial word dictionary\r\n  selectedLanguages.map((language) => {\r\n    languageData[language] = {}\r\n  })\r\n  updateLanguageDict(languageData, selectedLanguages)\r\n  updateLanguageGenders(languageData, selectedLanguages)\r\n  updateLanguageFlagURLs(languageData, selectedLanguages)\r\n  // console.log(languageData)\r\n\r\n}\r\n\r\n// load word dictionary into memory\r\nfunction updateLanguageDict(languageData, selectedLanguages) {\r\n  selectedLanguages.map(async (language) => {\r\n    // initialize map\r\n    languageData[language].dict = {}\r\n\r\n    // for each language, read its corresponding csv file for `WORD, GENDER` entries\r\n    const filePath = chrome.runtime.getURL('assets/data/dicts/' + language + \".csv\")\r\n    const response = await fetch(filePath)\r\n    if (response.ok) {\r\n      let text = await response.text()\r\n      text.split('\\n').map(line => {\r\n        const [word, gender] = line.split(',')\r\n        if (word && gender) {\r\n          languageData[language].dict[word] = gender.trim()\r\n        }\r\n      }) \r\n      console.log(language, 'language dict is loaded with', Object.keys(languageData[language].dict).length, 'entries')\r\n    } else {\r\n      console.error(EXTENSION_ALIAS, ': unable to load dict for ' + language)\r\n    }\r\n  })\r\n}\r\n\r\n// load genders, eg. {de: {f: 'feminin', . . .}, . . .}\r\nasync function updateLanguageGenders(languageData, selectedLanguages) {\r\n  const filePath = chrome.runtime.getURL('assets/data/genders.csv')\r\n  const response = await fetch(filePath)\r\n  if (response.ok) {\r\n    let text = await response.text()\r\n    // returns an object with corresponding {word: gender}\r\n    let langToGenderObj = genderCSVToObj(text)\r\n    Object.entries(langToGenderObj).forEach(([lang, genders]) => {\r\n      try {\r\n        languageData[lang].genders = genders        \r\n      } catch (e) {\r\n        if (!(e instanceof TypeError)) throw(e)\r\n      }\r\n    })\r\n  }\r\n}\r\n\r\nfunction updateLanguageFlagURLs(languageData, selectedLanguages) {\r\n  selectedLanguages.map( (language) => {\r\n    languageData[language].flagURL = chrome.runtime.getURL(`assets/data/flags/${language}.svg`)\r\n  })\r\n}\r\n\r\n// listen to tab events\r\nchrome.runtime.onMessage.addListener(\r\n  (request, sender, sendResponse) => {\r\n    switch (request.type) { \r\n\r\n      case 'getGender':\r\n        let data = []\r\n        options.selectedLanguages.value.map(language => {\r\n          const gender = languageData[language].dict[request.word]\r\n          const wordForGender = languageData[language].genders[gender]\r\n          const flagURL = languageData[language].flagURL\r\n          if (gender) data.push({countryCode: language, gender, wordForGender, flagURL, isSvelteComponent: false,})\r\n        })\r\n        sortObjectArrayByKey(data, 'language')\r\n        sendResponse({data})\r\n        break\r\n\r\n      case 'isExtensionOn':\r\n        sendResponse({isExtensionOn})\r\n        break\r\n        \r\n      case 'updateOptions':\r\n        options = request.data\r\n        initLanguages()\r\n        messageAllTabs({type: 'updateOptions', data: request.data})\r\n        break\r\n\r\n      case 'runAnkiRequest':\r\n        ankiRequest(request.data.action, request.data.params).then(response => {\r\n          sendResponse({response})\r\n        })\r\n        return true\r\n\r\n      default:\r\n        break\r\n    }\r\n  }\r\n)\r\n\r\n// TODO: pay attention to when this (note from the future: never leave a comment unfinished, now idk what this was about)\r\nchrome.tabs.onUpdated.addListener((tabId, changeInfo, tab) => {\r\n  if (changeInfo.status == 'complete') {\r\n  }\r\n})\r\n\r\n\r\nbrowserAction.setBadgeBackgroundColor({\r\n  color: [245, 30, 30, 255]\r\n});\r\n// listen to click on extension icon\r\nbrowserAction.onClicked.addListener((tab) => {\r\n  messageAllTabs({type: isExtensionOn ? 'disableExtension' : 'enableExtension'})\r\n\r\n  isExtensionOn = !isExtensionOn\r\n  updateBadgeText()\r\n  console.log(EXTENSION_ALIAS, ': toggling extension! now', isExtensionOn)\r\n});\r\n\r\nfunction updateBadgeText() {\r\n  if (isExtensionOn) {\r\n    browserAction.setBadgeText({text: 'On'})\r\n  } else {\r\n    browserAction.setBadgeText({text: ''})\r\n  }  \r\n}\r\n\r\n// yes i wrote my own parser, totally very fail-safe\r\nfunction genderCSVToObj(stringCSV) {\r\n  let output = {}\r\n  const lines = stringCSV.split('\\n')\r\n  // we already know how the header is so let's just skip it by setting i to 1\r\n  for (let i=1; i<lines.length; i++) {\r\n      const contents = lines[i].split(',')\r\n      output[contents[0]] = {\r\n        'm': contents[1],\r\n        'f': contents[2],\r\n        'n': contents[3].trim()\r\n      }\r\n  }\r\n  return output\r\n}\r\n  })()"],"names":["languageData","IS_CHROME","DEFAULT_OPTIONS","IN_DEV","options","browserStorageSync","result","isExtensionOn","updateBadgeText","initLanguages","selectedLanguages","language","updateLanguageDict","updateLanguageGenders","updateLanguageFlagURLs","filePath","response","line","word","gender","EXTENSION_ALIAS","text","langToGenderObj","genderCSVToObj","lang","genders","e","request","sender","sendResponse","data","wordForGender","flagURL","sortObjectArrayByKey","messageAllTabs","ankiRequest","tabId","changeInfo","tab","browserAction","stringCSV","output","lines","i","contents"],"mappings":"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"}